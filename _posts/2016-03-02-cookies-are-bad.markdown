---
layout: post
title: "cookies"
date: 2016-03-02 09:53:25
tags: cookies
---

원문 : [http://sitr.us/2011/08/26/cookies-are-bad-for-you.html](http://sitr.us/2011/08/26/cookies-are-bad-for-you.html)

쿠키는 여러모로 취약하다. 그래서 OAuth를 써야 한다.

### 우선 쿠키를 어떻게 사용해왔는지 부터 알아보자.

유저가 웹사이트에 접속하면(요청을 보내면) 쿠키를 만들어서 클라이언트(웹브라우져)에게 전달한다.
이제 웹브라우져는 해당 웹사이트에 대한 다음 요청부터는 위에서 받은 쿠키를 헤더에 포함시켜서 보내게 된다.(쿠키가 만료되기 전까지)
그리고 서버는 쿠키를 받게 되면 쿠키에 포함되어 있는 값을 확인하여 유저를 식별하게 된다.

예를 들어 

1. 홍길동이 Hello.com 웹사이트에 접속했더니 기본언어가 영어로 되어있다.
2. 홍길동은 한국인이라서 언어를 한국어로 바꾸는 요청을 했다.
3. Hello.com에서는 한국어 페이지를 반환하면서, 동시에 헤더의 Set-Cookie에 Lang=kor 라고 적어서 응답한다.
4. 웹브라우져는 Hello.com:Lang=kor 라는 쿠키를 로컬에 파일로 저장한다.
5. 시간이 흘러 홍길동이 다시 Hello.com에 접속한다.
6. 웹브라우져는 로컬에 Hello.com으로 저장되어 있는 쿠키가 있는지 확인하여 있다면 같이 보낸다.
7. 서버는 쿠키를 확인하여 언어가 한국어인 페이지를 기본으로 반환해준다.

### 왜 쿠키를 사용해야 할까?

쿠키를 사용하는 이유는 우리가 요청을 보내고 받을때 사용하는 HTTP 프로토콜이 Stateless 하기 때문이다.
따라서 매번 요청할때마다 현재의 상태를 같이 포함시켜서 보내는 것이다.

### 쿠키가 왜 취약한지 알아보자.

1. MITM (Man In The Middle) 

해커가 중간에서 패킷을 캡쳐해서 쿠키를 빼내는 것이다.
그리고는 캡쳐한 '쿠키'를 이용해서 자신이 마치 홍길동인 것처럼 위장하여 요청을 보내는 것이다.

이 문제는 HTTP Secure를 사용하여 패킷을 암호화 함으로써 해결할수 있다.

2. XSS (Cross-site scripting)

해커가 해킹하고자하는 사이트의 게시판에 악성 스크립트를 게시하고,
홍길동이 악성 게시글을 클릭하면 스크립트가 실행되면서 의도하지 않는 요청을 보내게 된다.
그리고 요청을 보낼때 해당 브라우져에 저장되어 있는 '쿠키'가 함께 보내지면서 사용자 인증이 통과되게 된다.

첫번째 해결방법은.. 
게시글에 자바스크립트를 포함하지 않도록 막음으로써 해결할수 있다.

두번째 해결방법은..
서버에서 Set-Cookie를 보낼때 httpOnly flag를 함께 보내면
웹브라우져에서는 해당 쿠키를 클라이언트 스크립트에서 접근하지 못하도록 차단하기 때문에 문제가 해결될수 있다.
 
3. CSRF (Cross-site request forgery)

홍길동이 bank.com에 접속하여 로그인을 하면 로컬에 쿠키가 저장된다. 
그리고 쿠키가 만료되기전에 badguy.com에 접속을 하였는데 badguy.com 페이지에서 홍길동 몰래 bank.com으로 요청을 보내는 것이다.
그러면 웹브라우져는 bank.com으로 저장되어 있는 '쿠키'를 찾아서 함께 보내게 되어 사용자 인증이 통과되게 된다.

첫번째 해결방법은..
이 문제는 모던 웹브라우져에 포함되어 있는 Same-origin Policy를 통해서 해결된다.
설명하자면 bank.com 페이지에서는 bank.com으로만 요청을 보낼수 있게 웹브라우져에서 막는 것이다.
만약 bank.com에서 badguy.com으로(다른 도메인으로:Cross-Origin) 요청을 보내게 되면 웹브라우져에서 해당 요청을 막아버린다.
 
하지만 최근 웹사이트는 ajax로 다른 도메인에 요청을 보내서 데이터를 받아오는 경우가 많다. 
그래서 위의 제한을 풀기위해 CORS (Cross-Origin Resource Sharing) 를 사용하는데,
CORS란.. bank.com에서 CORS를 설정해 놓았다면 badguy.com에서의 Cross-Origin 요청이 허용되는 것을 말한다.
따라서 bank.com에서 CORS를 허용했다면 CSRF 문제는 해결되지 않는다.

CSRF의 근본적인 원인은 bank.com의 api가 동일하기 때문이다.
bank.com 내부에서 요청할때도 bank.com/api/sendMoney 이고, badguy.com 내부에서 사용자몰래 요청할때도 bank.com/api/sendMoney 라면
둘다 똑같은 요청 URL 이기 때문에 서버는 어떤 요청이 올바른 요청인지 판단할수 없게 된다.

따라서 두번째 해결방법은..
서버측에서 템플릿 엔진으로 form을 생성할때 form에 유니크한 랜덤값인 Token을 넣는것이다.
그리고 클라이언트에서는 form을 submit 할때 해당 Token값을 함께 넘기고, 서버에서는 Token의 유효성을 검사하여 요청이 올바른지 확인하는 것이다.
이렇게 되면 badguy.com에서는 유효한 Token을 만들어낼수 없기 때문에 더이상 CSRF 공격을 할수 없게 된다.

하지만 이러한 방법은 ajax를 사용하는 경우는 불가능하다.
왜냐하면 CSRFToken은 페이지가 리로드 되어야지 갱신되는데, ajax는 페이지를 새로 불러오지 않고
계속해서 똑같은 CSRFToken으로 요청을 보내기 때문이다.

세번째 해결방법은..

MITM, XSS는 HTTP Secure와 HttpOnly flag로 해결할수 있다. 하지만 CSRF는 아니다.!!
웹을 보다 안전하게 만드는 방법은 사용자인증 도구로 웹브라우저를 사용하는 것이 아니라, 웹어플리케이션을 사용하는 것이다.
그리고 여기서는 OAuth 2.0에 대해서 설명하려고 한다.

OAuth는 아래와 같이 구성된다.

1. 인증 서버
2. 리소스 소유자
3. 클라이언트 

... 





